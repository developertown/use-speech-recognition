{"version":3,"file":"use-speech-recognition.cjs.production.min.js","sources":["../src/types/index.ts","../src/actions.ts","../src/reducer.ts","../src/index.tsx","../src/constants.ts"],"sourcesContent":["declare global {\n  interface Window {\n    webkitSpeechRecognition: unknown;\n    mozSpeechRecognition: unknown;\n    msSpeechRecognition: unknown;\n    oSpeechRecognition: unknown;\n  }\n}\n\nexport interface SpeechRecognitionUtils extends SpeechRecognitionState {\n  resetTranscript: () => void;\n  startListening: () => void;\n  stopListening: () => void;\n}\n\nexport interface SpeechRecognitionState {\n  status: SpeechRecognitionStatus;\n  transcript: string; // Transcription of all speech that has been spoken into the microphone. Is equivalent to the final transcript followed by the interim transcript, separated by a space.\n  interimTranscript: string; // Current word guesses before adding to transcript\n  finalTranscript: string; // Completed transcript\n}\n\nexport interface SpeechRecognitionInternalState extends SpeechRecognitionState {\n  pauseAfterDisconnect: boolean;\n}\n\nexport enum SpeechRecognitionStatus {\n  READY = \"ready\",\n  STOPPED = \"stopped\",\n  STARTED = \"started\",\n  ERROR = \"error\",\n  RESET = \"reset\",\n}\n\nexport interface SpeechRecognitionOptions {\n  autoStart: boolean;\n  continuous: boolean;\n  interimResults: boolean;\n  onResult: (final: string, interim: string) => void;\n  onDisconnect: () => void;\n  onStart: () => void;\n}\n\nexport enum SpeechRecognitionDisconnectType {\n  RESET = \"RESET\",\n  STOP = \"STOP\",\n}\n\nexport type Transcript = string;\n","import { actionCreatorFactory } from \"typescript-fsa\";\nimport { Transcript, SpeechRecognitionStatus } from \"./types\";\n\nconst createAction = actionCreatorFactory(\"SPEECH_RECOGNITION\");\n\nexport const setTranscript = createAction<Transcript>(\"SET_TRANSCRIPT\");\nexport const setStatus = createAction<SpeechRecognitionStatus>(\"SET_STATUS\");\nexport const setFinalTranscript = createAction<Transcript>(\"SET_FINAL_TRANSCRIPT\");\nexport const setInterimTranscript = createAction<Transcript>(\"SET_INTERIM_TRANSCRIPT\");\nexport const setPauseAfterDisconnect = createAction<boolean>(\"SET_PAUSE_AFTER_DISCONNECT\");\n","import { reducerWithInitialState } from \"typescript-fsa-reducers\";\nimport { SpeechRecognitionInternalState, SpeechRecognitionStatus } from \"./types\";\nimport { setInterimTranscript, setTranscript, setFinalTranscript, setStatus, setPauseAfterDisconnect } from \"./actions\";\n\nexport const initialState: SpeechRecognitionInternalState = {\n  status: SpeechRecognitionStatus.READY,\n  transcript: \"\",\n  interimTranscript: \"\",\n  finalTranscript: \"\",\n  pauseAfterDisconnect: false,\n};\n\nexport const speechRecognitionReducer = reducerWithInitialState(initialState)\n  .case(setTranscript, (state, transcript) => ({\n    ...state,\n    transcript,\n  }))\n  .case(setPauseAfterDisconnect, (state, pauseAfterDisconnect) => ({\n    ...state,\n    pauseAfterDisconnect,\n  }))\n  .case(setInterimTranscript, (state, interimTranscript) => ({\n    ...state,\n    interimTranscript,\n  }))\n  .case(setFinalTranscript, (state, finalTranscript) => ({\n    ...state,\n    finalTranscript,\n  }))\n  .case(setStatus, (state, status) => ({\n    ...state,\n    status,\n  }));\n\nexport default speechRecognitionReducer;\n","import { speechRecognitionReducer, initialState } from \"./reducer\";\nimport { useEffect, useCallback, useReducer, useMemo } from \"react\";\nimport {\n  SpeechRecognitionOptions,\n  SpeechRecognitionUtils,\n  SpeechRecognitionDisconnectType,\n  SpeechRecognitionStatus,\n} from \"./types\";\n\nimport { setPauseAfterDisconnect, setInterimTranscript, setFinalTranscript, setTranscript, setStatus } from \"./actions\";\nimport { ERROR_NO_RECOGNITION_SUPPORT } from \"./constants\";\n\nexport const defaultOptions: SpeechRecognitionOptions = {\n  autoStart: false,\n  continuous: false,\n  interimResults: true,\n  onResult: () => {},\n  onDisconnect: () => {},\n  onStart: () => {},\n};\n\nfunction concatTranscripts(...parts: string[]) {\n  return parts\n    .map((t) => t.trim())\n    .join(\" \")\n    .trim();\n}\n\nexport function useSpeechRecognition(options: SpeechRecognitionOptions = defaultOptions): SpeechRecognitionUtils {\n  const [{ status, pauseAfterDisconnect, interimTranscript, finalTranscript, transcript }, dispatch] = useReducer(\n    speechRecognitionReducer,\n    initialState,\n  );\n\n  const recognition = useMemo(() => {\n    const BrowserSpeechRecognition =\n      typeof window !== \"undefined\" &&\n      (window.SpeechRecognition ||\n        window.webkitSpeechRecognition ||\n        window.mozSpeechRecognition ||\n        window.msSpeechRecognition ||\n        window.oSpeechRecognition);\n\n    if (BrowserSpeechRecognition) {\n      return new BrowserSpeechRecognition();\n    } else {\n      throw new Error(ERROR_NO_RECOGNITION_SUPPORT);\n    }\n  }, []);\n\n  const disconnect = useCallback(\n    (disconnectType: SpeechRecognitionDisconnectType) => {\n      if (recognition) {\n        switch (disconnectType) {\n          case SpeechRecognitionDisconnectType.RESET:\n            dispatch(setStatus(SpeechRecognitionStatus.RESET));\n            dispatch(setPauseAfterDisconnect(false));\n            recognition.abort();\n            break;\n          case SpeechRecognitionDisconnectType.STOP:\n          default:\n            dispatch(setStatus(SpeechRecognitionStatus.STOPPED));\n            dispatch(setPauseAfterDisconnect(true));\n            recognition.stop();\n        }\n      }\n    },\n    [recognition],\n  );\n\n  const resetTranscript = useCallback(() => {\n    disconnect(SpeechRecognitionDisconnectType.RESET);\n    dispatch(setTranscript(\"\"));\n    dispatch(setInterimTranscript(\"\"));\n    dispatch(setFinalTranscript(\"\"));\n  }, [disconnect]);\n\n  const startListening = useCallback(() => {\n    console.log(\"Running start listening\");\n    if (recognition && status !== SpeechRecognitionStatus.STARTED) {\n      if (!recognition.continuous) {\n        resetTranscript();\n      }\n\n      try {\n        recognition.start();\n        dispatch(setStatus(SpeechRecognitionStatus.STARTED));\n      } catch (DOMException) {\n        // Tried to start recognition after it has already started - safe to swallow this error\n      }\n    }\n  }, [status, recognition, resetTranscript]);\n\n  const stopListening = useCallback(() => {\n    console.log(\"Running stop listening\");\n    disconnect(SpeechRecognitionDisconnectType.STOP);\n    dispatch(setStatus(SpeechRecognitionStatus.STOPPED));\n  }, [disconnect]);\n\n  const updateTranscript = useCallback(\n    (event: SpeechRecognitionEvent) => {\n      console.log(\"updating transcript\", event);\n      let interim = \"\";\n      let final = \"\";\n      for (let i = event.resultIndex; i < event.results.length; ++i) {\n        if (event.results[i].isFinal) {\n          final = concatTranscripts(final, event.results[i][0].transcript);\n        } else {\n          interim = concatTranscripts(interim, event.results[i][0].transcript);\n        }\n      }\n      dispatch(setTranscript(concatTranscripts(final, interim)));\n      dispatch(setInterimTranscript(interim));\n      dispatch(setFinalTranscript(final));\n\n      if (options.onResult) {\n        options.onResult(final, interim);\n      }\n    },\n    [options],\n  );\n\n  const onRecognitionDisconnect = useCallback(() => {\n    dispatch(setStatus(SpeechRecognitionStatus.STOPPED));\n    if (pauseAfterDisconnect) {\n      dispatch(setStatus(SpeechRecognitionStatus.STOPPED));\n    } else if (recognition) {\n      if (recognition.continuous) {\n        startListening();\n      } else {\n        dispatch(setStatus(SpeechRecognitionStatus.STOPPED));\n      }\n    }\n    dispatch(setPauseAfterDisconnect(false));\n  }, [pauseAfterDisconnect, recognition, startListening]);\n\n  const onRecognitionError = useCallback(({ error, message }) => {\n    console.log(\"Speech recognition error detected: \" + error);\n    console.log(\"Additional information: \" + message);\n  }, []);\n\n  useEffect(() => {\n    if (recognition) {\n      recognition.continuous = options.continuous !== false;\n      recognition.interimResults = options.interimResults;\n      recognition.onresult = updateTranscript;\n      recognition.onend = onRecognitionDisconnect;\n      recognition.onerror = onRecognitionError;\n    }\n  }, [\n    onRecognitionDisconnect,\n    onRecognitionError,\n    updateTranscript,\n    recognition,\n    options.continuous,\n    options.interimResults,\n  ]);\n\n  useEffect(() => {\n    if (recognition && options && options.autoStart) {\n      startListening();\n    }\n\n    return () => {\n      if (options && options.autoStart && status === SpeechRecognitionStatus.STARTED) {\n        stopListening();\n      }\n    };\n  }, [options, recognition, startListening, status, stopListening]);\n\n  return {\n    transcript,\n    interimTranscript,\n    finalTranscript,\n    status,\n    resetTranscript,\n    startListening,\n    stopListening,\n  };\n}\n","export const ERROR_NO_RECOGNITION_SUPPORT = \"Speech recognition is not supported on this device\";\n"],"names":["SpeechRecognitionStatus","SpeechRecognitionDisconnectType","createAction","actionCreatorFactory","setTranscript","setStatus","setFinalTranscript","setInterimTranscript","setPauseAfterDisconnect","initialState","status","READY","transcript","interimTranscript","finalTranscript","pauseAfterDisconnect","speechRecognitionReducer","reducerWithInitialState","state","defaultOptions","autoStart","continuous","interimResults","onResult","onDisconnect","onStart","concatTranscripts","parts","map","t","trim","join","options","useReducer","dispatch","recognition","useMemo","BrowserSpeechRecognition","window","SpeechRecognition","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","Error","disconnect","useCallback","disconnectType","RESET","abort","STOP","STOPPED","stop","resetTranscript","startListening","console","log","STARTED","start","DOMException","stopListening","updateTranscript","event","interim","final","i","resultIndex","results","length","isFinal","onRecognitionDisconnect","onRecognitionError","message","error","useEffect","onresult","onend","onerror"],"mappings":"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"}