{"version":3,"file":"use-speech-recognition.cjs.production.min.js","sources":["../src/types/index.ts","../src/actions.ts","../src/reducer.ts","../src/index.tsx"],"sourcesContent":["export interface SpeechRecognitionUtils {\n  transcript: string; // Transcription of all speech that has been spoken into the microphone. Is equivalent to the final transcript followed by the interim transcript, separated by a space.\n  interimTranscript: string; // Current word guesses before adding to transcript\n  finalTranscript: string; // Completed transcript\n  listening: boolean; // API is currently listening via microphone\n  status: SpeechRecognitionStatus;\n  recognition?: SpeechRecognition;\n  resetTranscript: () => void;\n  startListening: () => void;\n  stopListening: () => void;\n  abortListening: () => void;\n}\n\nexport interface SpeechRecognitionState {\n  status: SpeechRecognitionStatus;\n  transcript: string; // Transcription of all speech that has been spoken into the microphone. Is equivalent to the final transcript followed by the interim transcript, separated by a space.\n  interimTranscript: string; // Current word guesses before adding to transcript\n  finalTranscript: string; // Completed transcript\n  listening: boolean; // API is currently listening via microphone\n  pauseAfterDisconnect: boolean;\n  // recognition?: SpeechRecognition;\n}\n\nexport enum SpeechRecognitionStatus {\n  READY = \"ready\",\n  STOPPED = \"stopped\",\n  STARTED = \"started\",\n  ERROR = \"error\",\n  RESET = \"reset\",\n  ABORTED = \"aborted\",\n}\n\nexport interface SpeechRecognitionOptions {\n  autoStart: boolean;\n  continuous: boolean;\n  interimResults: boolean;\n  onResult: (final: string, interim: string) => void;\n  onDisconnect: () => void;\n  onStart: () => void;\n}\n\nexport enum SpeechRecognitionDisconnectType {\n  ABORT = \"ABORT\",\n  RESET = \"RESET\",\n  STOP = \"STOP\",\n}\n\nexport type Transcript = string;\n","import { actionCreatorFactory } from \"typescript-fsa\";\nimport { Transcript, SpeechRecognitionStatus } from \"./types\";\n\nconst createAction = actionCreatorFactory(\"SPEECH_RECOGNITION\");\n\nexport const setTranscript = createAction<Transcript>(\"SET_TRANSCRIPT\");\nexport const setStatus = createAction<SpeechRecognitionStatus>(\"SET_STATUS\");\nexport const setFinalTranscript = createAction<Transcript>(\"SET_FINAL_TRANSCRIPT\");\nexport const setInterimTranscript = createAction<Transcript>(\"SET_INTERIM_TRANSCRIPT\");\nexport const setListening = createAction<boolean>(\"SET_LISTENING\");\nexport const setPauseAfterDisconnect = createAction<boolean>(\"SET_PAUSE_AFTER_DISCONNECT\");\n","import { reducerWithInitialState } from \"typescript-fsa-reducers\";\nimport { SpeechRecognitionState, SpeechRecognitionStatus } from \"./types\";\nimport {\n  setInterimTranscript,\n  setTranscript,\n  setFinalTranscript,\n  setListening,\n  setStatus,\n  setPauseAfterDisconnect,\n} from \"./actions\";\n\nexport const initialState: SpeechRecognitionState = {\n  status: SpeechRecognitionStatus.READY,\n  transcript: \"\",\n  interimTranscript: \"\",\n  finalTranscript: \"\",\n  listening: false,\n  pauseAfterDisconnect: false,\n};\n\nexport const speechRecognitionReducer = reducerWithInitialState(initialState)\n  .case(setTranscript, (state, transcript) => ({\n    ...state,\n    transcript,\n  }))\n  .case(setPauseAfterDisconnect, (state, pauseAfterDisconnect) => ({\n    ...state,\n    pauseAfterDisconnect,\n  }))\n  .case(setInterimTranscript, (state, interimTranscript) => ({\n    ...state,\n    interimTranscript,\n  }))\n  .case(setFinalTranscript, (state, finalTranscript) => ({\n    ...state,\n    finalTranscript,\n  }))\n  .case(setStatus, (state, status) => ({\n    ...state,\n    status,\n  }))\n  .case(setListening, (state, listening) => ({\n    ...state,\n    listening,\n  }));\n\nexport default speechRecognitionReducer;\n","import { speechRecognitionReducer, initialState } from \"./reducer\";\nimport { useEffect, useCallback, useReducer } from \"react\";\nimport {\n  SpeechRecognitionOptions,\n  SpeechRecognitionUtils,\n  SpeechRecognitionDisconnectType,\n  SpeechRecognitionStatus,\n} from \"./types\";\n\nimport {\n  setListening,\n  setPauseAfterDisconnect,\n  setInterimTranscript,\n  setFinalTranscript,\n  setTranscript,\n  setStatus,\n} from \"./actions\";\n\ndeclare global {\n  interface Window {\n    webkitSpeechRecognition: unknown;\n    mozSpeechRecognition: unknown;\n    msSpeechRecognition: unknown;\n    oSpeechRecognition: unknown;\n  }\n}\n\nexport const defaultOptions: SpeechRecognitionOptions = {\n  autoStart: false,\n  continuous: false,\n  interimResults: true,\n  onResult: () => {},\n  onDisconnect: () => {},\n  onStart: () => {},\n};\n\nfunction concatTranscripts(...parts: string[]) {\n  return parts\n    .map((t) => t.trim())\n    .join(\" \")\n    .trim();\n}\n\nexport function useSpeechRecognition(options: SpeechRecognitionOptions = defaultOptions): SpeechRecognitionUtils {\n  const BrowserSpeechRecognition =\n    typeof window !== \"undefined\" &&\n    (window.SpeechRecognition ||\n      window.webkitSpeechRecognition ||\n      window.mozSpeechRecognition ||\n      window.msSpeechRecognition ||\n      window.oSpeechRecognition);\n\n  const [\n    { listening, status, pauseAfterDisconnect, interimTranscript, finalTranscript, transcript },\n    dispatch,\n  ] = useReducer(speechRecognitionReducer, initialState);\n\n  const recognition = BrowserSpeechRecognition ? new BrowserSpeechRecognition() : undefined;\n\n  const disconnect = useCallback(\n    (disconnectType: SpeechRecognitionDisconnectType) => {\n      if (recognition) {\n        switch (disconnectType) {\n          case SpeechRecognitionDisconnectType.ABORT:\n            dispatch(setStatus(SpeechRecognitionStatus.ABORTED));\n            dispatch(setPauseAfterDisconnect(true));\n            recognition.abort();\n            break;\n          case SpeechRecognitionDisconnectType.RESET:\n            dispatch(setStatus(SpeechRecognitionStatus.RESET));\n            dispatch(setPauseAfterDisconnect(false));\n            recognition.abort();\n            break;\n          case SpeechRecognitionDisconnectType.STOP:\n          default:\n            dispatch(setStatus(SpeechRecognitionStatus.STOPPED));\n            dispatch(setPauseAfterDisconnect(true));\n            recognition.stop();\n        }\n      }\n    },\n    [recognition],\n  );\n\n  const resetTranscript = useCallback(() => {\n    disconnect(SpeechRecognitionDisconnectType.RESET);\n    dispatch(setTranscript(\"\"));\n    dispatch(setInterimTranscript(\"\"));\n    dispatch(setFinalTranscript(\"\"));\n  }, [disconnect]);\n\n  const startListening = useCallback(() => {\n    if (recognition && !listening) {\n      if (!recognition.continuous) {\n        resetTranscript();\n      }\n      try {\n        recognition.start();\n      } catch (DOMException) {\n        // Tried to start recognition after it has already started - safe to swallow this error\n      }\n      dispatch(setStatus(SpeechRecognitionStatus.STARTED));\n      dispatch(setListening(true));\n    }\n  }, [listening, recognition, resetTranscript]);\n\n  const stopListening = useCallback(() => {\n    disconnect(SpeechRecognitionDisconnectType.STOP);\n    dispatch(setStatus(SpeechRecognitionStatus.STOPPED));\n    dispatch(setListening(false));\n  }, [disconnect]);\n\n  const abortListening = useCallback(() => {\n    dispatch(setListening(false));\n    disconnect(SpeechRecognitionDisconnectType.ABORT);\n  }, [disconnect]);\n\n  const updateTranscript = useCallback(\n    (event: SpeechRecognitionEvent) => {\n      console.log(\"updating transcript\", event);\n      let interim = \"\";\n      let final = \"\";\n      for (let i = event.resultIndex; i < event.results.length; ++i) {\n        if (event.results[i].isFinal) {\n          final = concatTranscripts(final, event.results[i][0].transcript);\n        } else {\n          interim = concatTranscripts(interim, event.results[i][0].transcript);\n        }\n      }\n      dispatch(setTranscript(concatTranscripts(final, interim)));\n      dispatch(setInterimTranscript(interim));\n      dispatch(setFinalTranscript(final));\n\n      if (options.onResult) {\n        options.onResult(final, interim);\n      }\n    },\n    [options],\n  );\n\n  const onRecognitionDisconnect = useCallback(() => {\n    dispatch(setStatus(SpeechRecognitionStatus.STOPPED));\n    if (pauseAfterDisconnect) {\n      dispatch(setListening(false));\n    } else if (recognition) {\n      if (recognition.continuous) {\n        startListening();\n      } else {\n        dispatch(setListening(false));\n      }\n    }\n    dispatch(setPauseAfterDisconnect(false));\n  }, [pauseAfterDisconnect, recognition, startListening]);\n\n  const onRecognitionError = useCallback(({ error, message }) => {\n    console.log(\"Speech recognition error detected: \" + error);\n    console.log(\"Additional information: \" + message);\n  }, []);\n\n  useEffect(() => {\n    if (recognition && !listening) {\n      recognition.continuous = options.continuous !== false;\n      recognition.interimResults = options.interimResults;\n      recognition.onresult = updateTranscript;\n      recognition.onend = onRecognitionDisconnect;\n      recognition.onerror = onRecognitionError;\n    }\n\n    if (recognition && options && options.autoStart) {\n      recognition.start();\n      dispatch(setListening(true));\n    }\n  }, [listening, onRecognitionDisconnect, onRecognitionError, options, recognition, updateTranscript]);\n\n  return {\n    transcript,\n    interimTranscript,\n    finalTranscript,\n    status,\n    listening,\n    recognition,\n    resetTranscript,\n    startListening,\n    stopListening,\n    abortListening,\n  };\n}\n"],"names":["SpeechRecognitionStatus","SpeechRecognitionDisconnectType","createAction","actionCreatorFactory","setTranscript","setStatus","setFinalTranscript","setInterimTranscript","setListening","setPauseAfterDisconnect","initialState","status","READY","transcript","interimTranscript","finalTranscript","listening","pauseAfterDisconnect","speechRecognitionReducer","reducerWithInitialState","state","defaultOptions","autoStart","continuous","interimResults","onResult","onDisconnect","onStart","concatTranscripts","parts","map","t","trim","join","options","BrowserSpeechRecognition","window","SpeechRecognition","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","useReducer","dispatch","recognition","undefined","disconnect","useCallback","disconnectType","ABORT","ABORTED","abort","RESET","STOP","STOPPED","stop","resetTranscript","startListening","start","DOMException","STARTED","stopListening","abortListening","updateTranscript","event","console","log","interim","final","i","resultIndex","results","length","isFinal","onRecognitionDisconnect","onRecognitionError","message","error","useEffect","onresult","onend","onerror"],"mappings":"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"}